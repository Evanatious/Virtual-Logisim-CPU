# CS61CPU

Look ma, I made a CPU! Here's what we did:

Throughout our time working on CS61CPU, we managed to find a very nice division of labor. Part A was a great introduction for us into using many of the features of Logisim, and we managed to complete it fairly quickly. When it came to Part B, we split the work; Dominic did most of the datapath, immediate generator, partial store/load circuits, while I focused my energy on figuring out the control logic for each task. Near around task 8, we started to consolidate our work as we slowly started to merge our circuits and understand much of the CPU at a big-picture level. While working on the project, we came across many bugs. Many were due to placing tunnels at the wrong parts of the circuit; for example, placing a tunnel that was supposed to connect the PC+4 signal to the output of the WBsel mux, after the PCsel mux rather than before it. Many of these bugs were found by comparing our results in the console with the expected results, and finding patterns in the discrepancies that showed up. Many times, a register was off consistently by a constant amount throughout every time-step, which we could then trace back through the wiring to find a misplaced tunnel. Other times, we would get results that we expected to receive for a different test or operation, which we would later realize was a mistake in our control logic. One of the most frustrating bugs we had however, was when our output was undefined. We tried looking at every part of our circuit, but all the logic seemed to be correct. It wasn't till we went step by step and traced the circuit from top to bottom through every half cycle, that we found a short circuit between two of the inputs to the control logic that we accidentally created. From these mistakes however, we were able to learn how certain patterns often originated from similar mistakes. We also learned how to partition work off and, as Professor Denero would put it, "stick to abstraction barriers". Our workload was much simpler when we didn't have to understand how every single part of the CPU worked all the time, but rather when we could focus on one small section of one subcircuit at a time. A particular task that we learned a lot from was implementing the jal and jalr instructions, at least when it came to the control logic. Those instructions shared the same three starting bits of the opcode as B-types. Initially, we used those three bits to determine how the control logic would work, but after realizing we need even more info to distinguish those instructions, even more hardware needed to be implemented. (We settled on adding a completely new mux at the end that would determine whether or not the instruction was one of the last four instructions ) We learned that sometimes, it was beneficial to look ahead, and not only plan for what you expect currently, but what may come in the future. Luckily, nothing else quite needed such an overhaul, but it was a good lesson in teaching the importance of foresight. If we were to change one thing about the project, it would be to teach some more Logisim tips and tricks in the beginning, or perhaps in the Logisim lab. We spent a long time on implementing the regfile circuit, when we could've shortened it a lot with some hotkeys and shortcuts that we found on YouTube.